/**
 * PackNum.
 * Tiny library that allow you encode/decode numbers to represent as string symbols.
 *
 * Copyright © 2021 Vitaliy Dyukar.
 */

var _charToCode = [
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
	0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E,
	0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E,
	0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
	0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E];

var _codeToChar = [
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
	'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'Ё', 'А', 'Б', 'В', 'Г', 'Д', 'Е',
	'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь',
	'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у',
	'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'ё'];

var _pow10 = [
	0x0000000000000001, 0x000000000000000A, 0x0000000000000064, 0x00000000000003E8, 0x0000000000002710,
	0x00000000000186A0, 0x00000000000F4240, 0x0000000000989680, 0x0000000005F5E100, 0x000000003B9ACA00,
	0x00000002540BE400, 0x000000174876E800, 0x000000E8D4A51000, 0x000009184E72A000, 0x00005AF3107A4000,
	0x00038D7EA4C68000, 0x002386F26FC10000, 0x016345785D8A0000, 0x0DE0B6B3A7640000, 0x8AC7230489E80000];

function charCodeFromUtf8ToWin1251(char) {
	var code = char.charCodeAt(0);
	if (code <= 0x7F) return code;
	if (code <= 0x400) return;
	if (code === 0x401) {
		code = 0x3F8;
	} else if (code == 0x451) {
		code = 0x408;
	}
	return code - 0x350;
}

function parseNumber(value, radix = 10) {
	if (radix === 10) return +value;
	if (typeof value !== 'string' || !value) return;
	if (value.indexOf('.') < 0) return parseInt(value, radix);
	var parts = value.split('.');
	if (parts.length != 2) return;
	var frac = parts[1] ? parseInt(parts[1], radix) : 0;
	if (isNaN(frac) || (frac < 0)) return;
	var int = (parts[0] && (parts[0] !== '-') && (parts[0] !== '+')) ? Math.abs(parseInt(parts[0], radix)) : 0;
	var sign = (value[0] === '-') ? -1 : 1;
	return sign * (int + (frac ? (frac * Math.pow(radix, -Math.min((parts[1] || '').length, 19))) : 0));
}

function trunc(value, precision = 0) {
	const factor = value <= 19 ? _pow10[Math.max(precision, 0)] : Math.pow(10, precision);
	return ((value < 0) ? Math.ceil(value * factor) : Math.floor(value * factor)) / factor;
}

function encode(value, precision, neg) {
	if ((value < 64) && (precision === 0)) {
		var num = value;
		if (neg) num = 0x7F - num;
		return _codeToChar[num];
	}
	var len = (value >= 0xFE00001)
		? (value >= 0x3F800000001)
			? (value >= 0xFE000000000001)
				? +(value >= 0x7F00000000000001) + 9
				: +(value >= 0x1FC0000000001) + 7
			: +(value >= 0x7F0000001) + 5
		: (value >= 0x3F81)
			? +(value >= 0x1FC001) + 3
			: +(value >= 0x80) + 1;

	var bit = (len > 9) && trunc(value / 0x8000000000000000);
	var meta = 0;
	if (bit) meta |= 0x20;
	if (neg) meta |= 0x40;
	if (precision) meta |= precision;
	var int = value;
	var result = new Array(len + 1);
	result[len] = _codeToChar[meta];
	do {
		len--;
		var code = int & 0x7F;
		if (neg) code = 0x7F - code;
		result[len] = _codeToChar[code];
		int = trunc(int / 0x80);
	} while (len > 0);
	return result.join('');
}

export function packNumDecode(value, radix = 10) {
	if (!(value || '').length) return;
	var result;
	if (value.length === 1) {
		result = _charToCode[charCodeFromUtf8ToWin1251(value[0])];
		if (result >= 64) result -= 0x7F;
		return (radix === 10) ? result : result.toString(radix);
	}
	var len = Math.min(value.length, 10) - 1;
	var meta = _charToCode[charCodeFromUtf8ToWin1251(value[len])];
	var bit = (meta & 0x20) > 0;
	var neg = (meta & 0x40) > 0;
	var precision = meta & 0x1F;
	result = bit ? 1 : 0;
	for (var i = 0; i < len; i++) {
		var code = _charToCode[charCodeFromUtf8ToWin1251(value[i])];
		if (neg) code = 0x7F - code;
		result = result * 0x80 + code;
	}
	if (neg) result = -result;
	if (precision > 0) result = result / _pow10[precision];
	return (radix === 10) ? result : result.toString(radix);
}

export function packNumEncode(value, radix = 10) {
	var parsed = parseNumber(value, radix);
	if (isNaN(parsed)) return;
	var float = Math.abs(parsed);
	var precision = 0;
	while (float !== trunc(float, precision)) precision++;
	return encode(float * _pow10[precision], precision, parsed < 0);
}